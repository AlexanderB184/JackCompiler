#include <chrono>
#include <iostream>

#include "./Lexer/Lexer.h"
#include "./Lexer/LexerOut.h"

int main(int argc, char const *argv[]) {
  // Start measuring time
  size_t total_duration = 0;
  size_t trials = 10000;
  for (int i = 0; i < trials; i++) {
    auto start = std::chrono::high_resolution_clock::now();
    std::vector<Jack::Token> v = Jack::tokenize(
        "class list {\n\tfield int value;\n\tfield list next;\n/**\n * "
        "Constructs a "
        "default list node\n*/\nconstructor list new(int value) {\nvar list "
        "self;\nlet self = Memory.alloc(2);\nreturn self;\n}\n/**\n     * "
        "Destroys one list node\n*/\nmethod void dispose() {\nif (~(this = "
        "null)) {\ndo "
        "Memory.deAlloc(this);\n}\nreturn;\n}\n\t\t\n\t\t/**\n\t\t* "
        "Destroys the entire list\n*/\t\t\n\t\tmethod void delete() "
        "{\t\t\t\nif "
        "(~(this = null)) {\n\t\t\t\tdo next.delete();  // recursively destroy "
        "list\n\t\t\t\tdo "
        "Memory.deAlloc(this);\n\t\t\t}\n\t\treturn;\n\t\t}\n\n\t\tmethod void "
        "setValue(int newValue) {\n\t\tlet value = "
        "newValue;\n\t\treturn;\n\t\t}\n\t\tmethod void setNext(list newNext) "
        "{\n\t\tlet next = newNext;\n\t\treturn;\n\t\t}\n\t\tmethod int "
        "value() "
        "{\n\t\treturn value;\n\t\t}\n\t\tmethod list next() {\n\t\treturn "
        "next;\n\t\t}\n\t\tmethod list push(int value) {\n\t\tvar list "
        "newNode;\n\t\tlet newNode = new ();\n\t\tdo "
        "newNode.setValue(value);\n\t\tdo newNode.setNext(this);\n\t\treturn "
        "newNode;\n\t\t}\n\t\tmethod list pop() {\n\t\tvar list "
        "nextNode;\n\t\tif (next = null) {\n\t\t  return null;\n\t\t}\n\t\tlet "
        "nextNode = next;\n\t\tdo dispose(this);\n\t\treturn "
        "nextNode;\n\t\t}\n\t\tmethod list insert(int where, int what) "
        "{\n\t\tvar list newNode;\n\t\tif (where < 1) {\n\t\t  let this = "
        "push(what);\n\t\t} else {\n\t\t  let this = insert(where - 1, "
        "what);\n\t\t}\n\t\treturn this;\n\t\t}\n\t\tmethod list remove(int "
        "what) {\n\t\t// this is not an lvalue so we must create a "
        "variable\n\t\tvar list curr;\n\t\tif (this = null) {\n\t\t  return "
        "null;\n\t\t}\n\t\tif (value = what) {\n\t\t  let curr = "
        "curr.pop();\n\t\t} else {\n\t\t  let next = "
        "next.remove(what);\n\t\t}\n\t\treturn curr;\n\t\t}\n\t\tmethod list "
        "removeAll(int what) {\n\t\tvar list curr;\n\t\tlet curr = "
        "this;\n\t\tif "
        "(this = null) {\n\t\t  return null;\n\t\t}\n\t\twhile (~(curr = null) "
        "/*Code to ensure correct order of operations*/ &\n\t\t       (value = "
        "what)) {\n\t\t  let curr = pop(curr);\n\t\t}\n\t\tif (~(curr = null)) "
        "{\n\t\t  let next = next.remove(what);\n\t\t}\n\t\treturn "
        "curr;\t\t}\n}"
        "class list {\n\tfield int value;\n\tfield list next;\n/**\n * "
        "Constructs a "
        "default list node\n*/\nconstructor list new(int value) {\nvar list "
        "self;\nlet self = Memory.alloc(2);\nreturn self;\n}\n/**\n     * "
        "Destroys one list node\n*/\nmethod void dispose() {\nif (~(this = "
        "null)) {\ndo "
        "Memory.deAlloc(this);\n}\nreturn;\n}\n\t\t\n\t\t/**\n\t\t* "
        "Destroys the entire list\n*/\t\t\n\t\tmethod void delete() "
        "{\t\t\t\nif "
        "(~(this = null)) {\n\t\t\t\tdo next.delete();  // recursively destroy "
        "list\n\t\t\t\tdo "
        "Memory.deAlloc(this);\n\t\t\t}\n\t\treturn;\n\t\t}\n\n\t\tmethod void "
        "setValue(int newValue) {\n\t\tlet value = "
        "newValue;\n\t\treturn;\n\t\t}\n\t\tmethod void setNext(list newNext) "
        "{\n\t\tlet next = newNext;\n\t\treturn;\n\t\t}\n\t\tmethod int "
        "value() "
        "{\n\t\treturn value;\n\t\t}\n\t\tmethod list next() {\n\t\treturn "
        "next;\n\t\t}\n\t\tmethod list push(int value) {\n\t\tvar list "
        "newNode;\n\t\tlet newNode = new ();\n\t\tdo "
        "newNode.setValue(value);\n\t\tdo newNode.setNext(this);\n\t\treturn "
        "newNode;\n\t\t}\n\t\tmethod list pop() {\n\t\tvar list "
        "nextNode;\n\t\tif (next = null) {\n\t\t  return null;\n\t\t}\n\t\tlet "
        "nextNode = next;\n\t\tdo dispose(this);\n\t\treturn "
        "nextNode;\n\t\t}\n\t\tmethod list insert(int where, int what) "
        "{\n\t\tvar list newNode;\n\t\tif (where < 1) {\n\t\t  let this = "
        "push(what);\n\t\t} else {\n\t\t  let this = insert(where - 1, "
        "what);\n\t\t}\n\t\treturn this;\n\t\t}\n\t\tmethod list remove(int "
        "what) {\n\t\t// this is not an lvalue so we must create a "
        "variable\n\t\tvar list curr;\n\t\tif (this = null) {\n\t\t  return "
        "null;\n\t\t}\n\t\tif (value = what) {\n\t\t  let curr = "
        "curr.pop();\n\t\t} else {\n\t\t  let next = "
        "next.remove(what);\n\t\t}\n\t\treturn curr;\n\t\t}\n\t\tmethod list "
        "removeAll(int what) {\n\t\tvar list curr;\n\t\tlet curr = "
        "this;\n\t\tif "
        "(this = null) {\n\t\t  return null;\n\t\t}\n\t\twhile (~(curr = null) "
        "/*Code to ensure correct order of operations*/ &\n\t\t       (value = "
        "what)) {\n\t\t  let curr = pop(curr);\n\t\t}\n\t\tif (~(curr = null)) "
        "{\n\t\t  let next = next.remove(what);\n\t\t}\n\t\treturn "
        "curr;\t\t}\n}"
        "class list {\n\tfield int value;\n\tfield list next;\n/**\n * "
        "Constructs a "
        "default list node\n*/\nconstructor list new(int value) {\nvar list "
        "self;\nlet self = Memory.alloc(2);\nreturn self;\n}\n/**\n     * "
        "Destroys one list node\n*/\nmethod void dispose() {\nif (~(this = "
        "null)) {\ndo "
        "Memory.deAlloc(this);\n}\nreturn;\n}\n\t\t\n\t\t/**\n\t\t* "
        "Destroys the entire list\n*/\t\t\n\t\tmethod void delete() "
        "{\t\t\t\nif "
        "(~(this = null)) {\n\t\t\t\tdo next.delete();  // recursively destroy "
        "list\n\t\t\t\tdo "
        "Memory.deAlloc(this);\n\t\t\t}\n\t\treturn;\n\t\t}\n\n\t\tmethod void "
        "setValue(int newValue) {\n\t\tlet value = "
        "newValue;\n\t\treturn;\n\t\t}\n\t\tmethod void setNext(list newNext) "
        "{\n\t\tlet next = newNext;\n\t\treturn;\n\t\t}\n\t\tmethod int "
        "value() "
        "{\n\t\treturn value;\n\t\t}\n\t\tmethod list next() {\n\t\treturn "
        "next;\n\t\t}\n\t\tmethod list push(int value) {\n\t\tvar list "
        "newNode;\n\t\tlet newNode = new ();\n\t\tdo "
        "newNode.setValue(value);\n\t\tdo newNode.setNext(this);\n\t\treturn "
        "newNode;\n\t\t}\n\t\tmethod list pop() {\n\t\tvar list "
        "nextNode;\n\t\tif (next = null) {\n\t\t  return null;\n\t\t}\n\t\tlet "
        "nextNode = next;\n\t\tdo dispose(this);\n\t\treturn "
        "nextNode;\n\t\t}\n\t\tmethod list insert(int where, int what) "
        "{\n\t\tvar list newNode;\n\t\tif (where < 1) {\n\t\t  let this = "
        "push(what);\n\t\t} else {\n\t\t  let this = insert(where - 1, "
        "what);\n\t\t}\n\t\treturn this;\n\t\t}\n\t\tmethod list remove(int "
        "what) {\n\t\t// this is not an lvalue so we must create a "
        "variable\n\t\tvar list curr;\n\t\tif (this = null) {\n\t\t  return "
        "null;\n\t\t}\n\t\tif (value = what) {\n\t\t  let curr = "
        "curr.pop();\n\t\t} else {\n\t\t  let next = "
        "next.remove(what);\n\t\t}\n\t\treturn curr;\n\t\t}\n\t\tmethod list "
        "removeAll(int what) {\n\t\tvar list curr;\n\t\tlet curr = "
        "this;\n\t\tif "
        "(this = null) {\n\t\t  return null;\n\t\t}\n\t\twhile (~(curr = null) "
        "/*Code to ensure correct order of operations*/ &\n\t\t       (value = "
        "what)) {\n\t\t  let curr = pop(curr);\n\t\t}\n\t\tif (~(curr = null)) "
        "{\n\t\t  let next = next.remove(what);\n\t\t}\n\t\treturn "
        "curr;\t\t}\n}");
    // Stop measuring time
    auto end = std::chrono::high_resolution_clock::now();

    // Calculate the duration
    auto duration =
        std::chrono::duration_cast<std::chrono::nanoseconds>(end - start)
            .count();
    total_duration += static_cast<long>(duration);
  }
  // Print the tokens and execution time
  std::cout << "Execution time: " << total_duration/trials << " ns" << std::endl;
  // std::cout << v << std::endl;
  return 0;
}
